package org.rtassembly;
import java.io.BufferedReader;
import java.io.File;
import java.io.IOException;
import java.io.InputStreamReader;
import java.lang.ProcessBuilder.Redirect;
import java.lang.invoke.MethodHandles;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.Date;

import org.apache.logging.log4j.Logger;
import org.apache.logging.log4j.LogManager;
import org.rtassembly.npgraph.Alignment;
import org.rtassembly.npgraph.grpc.AssemblyGuideGrpc;
import org.rtassembly.npgraph.grpc.AssemblyGuideGrpc.AssemblyGuideBlockingStub;
import org.rtassembly.npgraph.grpc.RequestAssembly;
import org.rtassembly.npgraph.grpc.RequestAssembly.Builder;
import org.rtassembly.npgraph.grpc.ResponseAssembly;
import org.rtassembly.npgraph.grpc.AlignmentMsg;

import io.grpc.ManagedChannel;
import io.grpc.ManagedChannelBuilder;
import io.grpc.StatusRuntimeException;
import java.util.concurrent.TimeUnit;

import japsa.seq.PAFRecord;
import japsa.util.CommandLine;


public class NPGraphClientCmd extends CommandLine{
    private static final Logger logger = LogManager.getLogger(MethodHandles.lookup().lookupClass());
    private static ManagedChannel channel; 
    private static AssemblyGuideBlockingStub stub;
    
	public NPGraphClientCmd(){
		super();
		addString("target","localhost:2105","The server to connect to.");
		//Input settings
		addString("si", "", "Name of the short read FASTA pre-assembly (assembly_graph.fasta) generated by the server");
		addString("li", "", "Name of the long-read data input file (fasta/fastq), - for stdin.");
		addStdHelp();
	}
	
	private static void testServer(ArrayList<PAFRecord> hits, String readID) {
		if(hits.isEmpty())
			return;
		
		Builder requestBuilder = RequestAssembly.newBuilder();
		requestBuilder.setReadId(readID);
		for(PAFRecord rec:hits){
			AlignmentMsg msg = AlignmentMsg.newBuilder()
											.setQueryName(rec.qname)
											.setQueryLength(rec.qlen)
											.setQueryStart(rec.qstart)
											.setQueryEnd(rec.qend)
											.setStrand(rec.strand)
											.setTargetName(rec.tname)
											.setTargetLength(rec.tlen)
											.setTargetStart(rec.tstart)
											.setTargetEnd(rec.tend)
											.setQuality(rec.qual)
											.setScore(rec.score)
											.build();
			requestBuilder.addHitsList(msg);
		}
		RequestAssembly request = requestBuilder.build();
		try {
			long before=System.currentTimeMillis();
			ResponseAssembly response = stub.getAssemblyContribution(request);
			long interval=System.currentTimeMillis()-before;
			logger.info("Get response from server in {} ms: read {} is {}", interval, response.getReadId(), (response.getUsefulness()?"useful":"not useful"));
		} catch (StatusRuntimeException e) {
			  logger.warn("RPC failed: {}", e);
		}
		return;
		
	}
	public static void main(String[] args) throws IOException, InterruptedException{
		CommandLine cmdLine = new NPGraphClientCmd();		
		args = cmdLine.stdParseLine(args);

		/***********************************************************************/
		String 	target = cmdLine.getStringVal("target"),
				reference = cmdLine.getStringVal("si"),
				query = cmdLine.getStringVal("li");
		String workDir="/tmp",
				algOpts = "-t4 -k15 -w5",
				indexFileName=workDir+File.separator+"assembly_graph.mmi";
		
		ArrayList<String> command = new ArrayList<String>();
		File indexFile= new File(indexFileName);
		if(!indexFile.exists()) {
			command.add("minimap2");
			command.addAll(Arrays.asList(algOpts.split("\\s")));
			command.add("-d");
			command.add(indexFileName);
			command.add(reference);
			ProcessBuilder pb = new ProcessBuilder(command);
			Process indexProcess =  pb.start();
			indexProcess.waitFor();
		} 
		//from HybridAssembler.assembly2()
		logger.info("Starting alignment at {}", new Date());
		ProcessBuilder pb = null;
		command.add("minimap2");
		command.addAll(Arrays.asList(algOpts.split("\\s")));
		command.add("-K20000");
		command.add(indexFileName);
		command.add(query);
		

		
		if ("-".equals(query)){
			pb = new ProcessBuilder(command).redirectInput(Redirect.INHERIT);
		}else{
			pb = new ProcessBuilder(command);
		}

		Process alignmentProcess  = pb.redirectError(ProcessBuilder.Redirect.to(new File(workDir+File.separator+"alignment.log"))).start();

		logger.info("minimap2 started!");			
		InputStreamReader inputStream = new InputStreamReader(alignmentProcess.getInputStream());
		try(BufferedReader reader=new BufferedReader(inputStream)){
			String readID = "";
			ArrayList<PAFRecord> hits =  new ArrayList<PAFRecord>();// alignment record of the same read;	
			PAFRecord curRecord=null;
			String line;
			
		    channel = ManagedChannelBuilder.forTarget(target).usePlaintext().build();
		    stub = AssemblyGuideGrpc.newBlockingStub(channel);
		    
			while ((line=reader.readLine()) != null) {
				try {
					curRecord = new PAFRecord(line);
					logger.info("{} {} {} {} {} {} {} {} {}", 
								curRecord.qname,
								curRecord.qlen,
								curRecord.qstart,
								curRecord.qend,
								(curRecord.strand?"+":"-"),
								curRecord.tname,
								curRecord.tlen,
								curRecord.tstart,
								curRecord.tend);
					///////////////////////////////////////////////////
					if (curRecord.qual < Alignment.MIN_QUAL){		
						logger.info("Ignore low-quality map record: q={}", curRecord.qual);
						continue;		
					}
										
		
					//////////////////////////////////////////////////////////////////
					
					if (!readID.equals("") && !readID.equals(curRecord.qname)) {	
						//generate request and get response
						////////////////////////////////////
						testServer(hits, readID);
						hits = new ArrayList<PAFRecord>();

					}	
					readID = curRecord.qname;
					hits.add(curRecord); 
					 
				}catch(Exception e) {
					logger.error("Error record! \n {}", e);
					break;
				}
	
			}// while

		}catch(Exception e) {
			logger.error("Error reading alignment results: \n {}", e);
		}
		finally {
		      channel.shutdownNow().awaitTermination(5, TimeUnit.SECONDS);
	    }
		
		
	}
	
}
